<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">

<th:block>
<style>
    table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
    }
    th, td {
        border: 1px solid #d1d5db;
        padding: 10px;
        text-align: center;
    }
    th {
        background: #e5e7eb;
    }
</style>
    <h1>Chapter 9. MCP (Model Context Protocol)</h1><br>

    <h2>1. MCP(Model Context Protocol)</h2>
    <a href="https://modelcontextprotocol.io/docs/getting-started/intro">출처:Model Context Protocol</a>

    <p>
        <strong>Model Context Protocol(MCP)</strong>은 AI 모델이 외부 도구·데이터·리소스와 구조화된 방식으로 상호작용할 수 있게 해주는 표준화된 프로토콜입니다.
        모델과 현실 세계(데이터베이스, API, 파일 시스템 등)를 연결하는 통합 인터페이스 역할을 하며, 다양한 전송 메커니즘을 지원해 유연한 통신 패턴을 제공합니다.
    </p>


    <p>
        MCP는 2024년 11월에 공개된 이후 빠르게 주목받았으며, 2025년 초를 기점으로 생태계에서 널리 채택되고 있습니다.
        MCP Java SDK는 동기/비동기 통신 패턴을 모두 지원하는 Java 구현체를 제공하여, AI 모델과 도구 간의 표준화된 상호작용을 쉽게 구성할 수 있게 합니다.
    </p>

    <p>
        Spring AI는 MCP 전용 부트 스타터와 Java 어노테이션을 통해 MCP를 정밀히 지원합니다. 이를 통해 Spring 개발자는 MCP 서버를 호스트하거나 MCP 클라이언트로서 외부 모델과 연동하는 애플리케이션을 손쉽게 구축할 수 있습니다.
    </p>
    <p>
        'Context 정보'란 특정 대상(정보, 데이터, 애플리케이션 등)을 더 잘 이해하고 활용하기 위해 필요한 주변 상황, 맥락, 환경적 정보를 의미하며, 단순 데이터 이상의 '정보의 정보' 또는 '상황 정보'로, AI, 프로그래밍, 컴퓨팅 등 다양한 분야에서 작업의 이해도와 정확도를 높이는 데 필수적인 요소입니다.
        즉 AI 모델이 사용자의 질문을 정확히 이해하도록 돕는 채팅 기록, 사용자 선호도, 관련 문서 등의 주변 정보를 의미 합니다.
    </p>
    <p>

    </p>
    <p>
        Context 정보가 있으면, AI는 더 정확한 답변을, 애플리케이션은 사용자 상황에 맞는 서비스를 제공할 수 있고, 프로그램은 더 효율적으로 작동하게 됩니다. 이는 곧 사용자 경험을 향상시키고, 데이터를 기반으로 의미 있는 결정을 내리는 데 핵심적인 역할을 합니다.
    </p>

    <p>
        MCP는 메시지 직렬화 및 전송을 위한 다양한 구성요소(예: <code>McpTransport</code>)와 전송 프로토콜(STDIO, HTTP/SSE, Streamable-HTTP 등)을 지원합니다.
        이를 통해 모델·도구 간의 JSON-RPC 스타일 직렬화/역직렬화 및 다중 전송 채널을 표준화할 수 있습니다.
    </p>
    <img th:src="@{/imgs/mcp1.png}" width="600px;"><br><a href="https://docs.spring.io/spring-ai/reference/api/mcp/mcp-overview.html#_spring_ai_mcp_integration">출처:docs.springai.io</a><br><br>
    <img th:src="@{/imgs/mcp2.png}" width="600px;"><br><a href="https://docs.spring.io/spring-ai/reference/api/mcp/mcp-overview.html#_spring_ai_mcp_integration">출처:docs.springai.io</a><br><br>

    <hr>
    <h2>2. 왜 MCP가 필요한가?</h2>

    <ul>
        <li>
            <strong>지식 갱신의 한계 극복</strong><br>
            대규모 언어 모델(LLM)은 학습 시점까지의 정적 지식에 의존합니다. MCP를 통해 모델은 실시간 데이터 소스에 접근하여 최신 정보를 활용할 수 있습니다.
        </li>
        <li>
            <strong>전문 도메인 통합</strong><br>
            의료 기록, ERP, CRM 등 조직 내부의 전용 데이터 소스와 표준화된 방식으로 연결함으로써 도메인 특화 지식을 손쉽게 통합할 수 있습니다.
        </li>
        <li>
            <strong>개발 복잡도 감소</strong><br>
            다양한 데이터 소스 통합 로직을 프로토콜 수준에서 추상화하여 에이전트/애플리케이션 개발 비용과 통합 복잡도를 낮춥니다.
        </li>
    </ul>
    <p>
        즉, MCP Server는 LLM과 기업 시스템 사이에서
        <strong>Context, Tool, Resource</strong>를 안전하게 연결하는 역할을 한다.
    </p>
    <h4> MCP Server가 필요한 이유</h4>
    <ul>
        <li>LLM은 기본적으로 내부 데이터(DB, ERP)에 접근할 수 없음</li>
        <li>사내 API 호출 방식이 시스템마다 다름</li>
        <li>보안 및 접근 제어가 어려움</li>
        <li>LLM 벤더별 연동 방식 차이</li>
    </ul>
    <hr>

    <h2>3. MCP Server의 핵심 구성 요소</h2>
    <ul>
        <li>Tool: LLM이 실행할 수 있는 함수 (상태 변경 가능)</li>
        <li>Resource: LLM이 참고하는 읽기 전용 Context 데이터</li>
        <li>Prompt: 사전 정의된 도메인 업무 프롬프트 (선택)</li>
    </ul>
    <br>

    <h4>MCP Server 아키텍처 개념</h4>

    <pre>
┌────────────────────────────┐
│        LLM / Agent         │
│  (Spring AI, Claude 등)    │
└─────────────▲──────────────┘
              │ MCP (표준)
┌─────────────┴──────────────┐
│         MCP Gateway        │
│  (Auth / Rate / Routing)   │
└─────────────▲──────────────┘
              │
┌─────────────┴───────────────────────────┐
│              MCP Servers                │
│ ┌───────────┐ ┌───────────┐ ┌─────────┐ │
│ │ WebMVC MCP│ │WebFlux MCP│ │stdio MCP│ │
│ └───────────┘ └───────────┘ └─────────┘ │
└─────────────▲───────────────────────────┘
              │
┌─────────────┴──────────────┐
│      Enterprise Systems    │
│  (DB, ERP, API, File 등)   │
└────────────────────────────┘

</pre>

    <p>
        LLM은 시스템을 직접 호출하지 않고,
        <strong>반드시 MCP Server를 통해서만 접근</strong>한다.
    </p>

    <table>
        <tr>
            <th>구분</th>
            <th>설명</th>
            <th>예</th>
        </tr>
        <tr>
            <td>Tool (실행 가능 기능)</td>
            <td>
                상태 변경 가능,
                POST 기반,
                명확한 입력/출력 스키마
            </td>
            <td>예: 주문 상태 변경, 결제 승인, 티켓 생성</td>
        </tr>
        <tr>
            <td>Resource (Context 제공)</td>
            <td>
                읽기 전용,
                GET 기반,
                LLM 참고용 데이터
            </td>
            <td>예: 주문 상세, 사용자 정보, 정책 문서</td>
        </tr>
        <tr>
            <td>Prompt (선택)</td>
            <td>
                도메인 지식 고정,
                Agent 성격 정의
            </td>
            <td>예: "너는 결제 검증 Agent이다"</td>
        </tr>
    </table>

    <hr>

    <h2>4. MCP Server의 주요 특징</h2>

    <ul>
        <li>LLM 벤더 독립 (OpenAI, Claude, Gemini 등)</li>
        <li>보안 및 권한 통제 가능</li>
        <li>도메인별 MCP Server 분리 가능</li>
        <li>Agent 및 자동화 시스템 확장 용이</li>
    </ul>
    <hr>

    <h2>5. Spring AI Tool vs MCP Server</h2>

    <table>
        <tr>
            <th>구분</th>
            <th>Spring AI Tool</th>
            <th>MCP Server</th>
        </tr>
        <tr>
            <td>실행 범위</td>
            <td>애플리케이션 내부</td>
            <td>외부 독립 서버</td>
        </tr>
        <tr>
            <td>통신 방식</td>
            <td>In-Process</td>
            <td>HTTP</td>
        </tr>
        <tr>
            <td>MSA 적합성</td>
            <td>낮음</td>
            <td>높음</td>
        </tr>
        <tr>
            <td>언어 독립성</td>
            <td>없음</td>
            <td>있음</td>
        </tr>
    </table>
    <hr>
    <h2>6. MCP Server 구현 방식</h2>

    <table>
        <tr>
            <th>구현 방식</th>
            <th>설명</th>
            <th>목적 및 특징
        <tr>
            <td>WebMVC</td>
            <td>HTTP 기반, 엔터프라이즈 표준, 기존 Spring MVC 재사용</td>
            <td>
                내부 업무 시스템,
                단순 CRUD,
                엔터프라이즈 표준
            </td>
        </tr>
        <tr>
            <td>WebFlux</td>
            <td>Reactive 기반, Streaming 및 Agent 시스템에 최적</td>
            <td>
                Agent 기반 시스템,
                실시간 Context,
                동시성<br>
                권장영역: RAG,
                상태 추적,
                운영 자동화
            </td>
        </tr>
        <tr>
            <td>stdio</td>
            <td>stdin/stdout 기반, 로컬 CLI·IDE 자동화에 적합</td>
            <td>
                로컬 도구,
                CLI / IDE 연동,
                자동화 스크립트<br>
                네트워크 없음,
                OS 권한 기반 보안,
                단일 실행 파일
            </td>
        </tr>
    </table>


    <table>
        <tr>
            <th>항목</th>
            <th>WebMVC</th>
            <th>WebFlux</th>
            <th>stdio</th>
        </tr>
        <tr>
            <td>Streaming 지원</td>
            <td>제한적</td>
            <td>✅</td>
            <td>❌</td>
        </tr>
        <tr>
            <td>Agent Loop</td>
            <td>❌</td>
            <td>✅</td>
            <td>△</td>
        </tr>
        <tr>
            <td>MSA(Micro Service Architecture) 적합성</td>
            <td>✅</td>
            <td>✅</td>
            <td>❌</td>
        </tr>
        <tr>
            <td>로컬 자동화</td>
            <td>❌</td>
            <td>❌</td>
            <td>✅</td>
        </tr>
    </table>
<hr>
    <h2>7. MCP Server 실무 활용 예</h2>

    <ul>
        <li>사내 결제 MCP Server</li>
        <li>ERP / 인사 / 재무 MCP Server</li>
        <li>RAG 전용 MCP Server</li>
        <li>Agent 기반 자동 운영 시스템</li>
        <li>IDE / 개발 도구 연동 MCP</li>
    </ul>
    <strong>
        Spring WebMVC 기반 MCP Server는<br/>
        “기존 엔터프라이즈 시스템을 AI와 연결하는 가장 현실적인 MCP 구현 방식”이다.
    </strong>
    <hr>

    <h2>8. 구현 및 운영 고려사항</h2>

    <p>
        MCP를 도입할 때 고려해야 할 주요 항목:
    </p>

    <ul>
        <li><strong>보안 및 인증</strong> — 외부 시스템 접근 시 인증·권한 관리 및 민감 데이터 보호 설계 필요.</li>
        <li><strong>전송 안정성</strong> — STDIO, HTTP/SSE, Streamable-HTTP 등 다양한 채널의 지연·재전송 전략 수립.</li>
        <li><strong>스키마와 직렬화</strong> — JSON-RPC 기반 메시지 포맷과 스키마 호환성 관리.</li>
        <li><strong>관찰성(Observability)</strong> — 요청/응답 로깅, 트레이싱, 모니터링으로 문제 원인 파악 용이성 확보.</li>
        <li><strong>버전 관리</strong> — MCP 계약(스키마·엔드포인트)의 버전 관리를 통한 호환성 유지.</li>
    </ul>

    <hr>


    <h2>9. MCP Server Setting</h2>
    <h5>1) MCP Server webmvc</h5>
    <ol>
        <li>build.gradle
            <pre style="border:1px solid cornflowerblue">

                dependencies {
                    compileOnly 'org.projectlombok:lombok'
                    developmentOnly 'org.springframework.boot:spring-boot-devtools'
                    annotationProcessor 'org.projectlombok:lombok'
                    testImplementation 'org.springframework.boot:spring-boot-starter-test'
                    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

                    implementation 'org.springframework.ai:spring-ai-starter-mcp-server-webmvc'
                }
            </pre>
        </li>
        <li>application.yml
            <pre style="border:1px solid cornflowerblue">

server:
  port: 8088

spring:
  application:
    name: project
  profiles:
    active: local
  ai:
    mcp:
      server:
        name: mcp-server-weather-webmvc
        version: 0.0.1
        request-timeout: 20s
        protocol: sse  #default
        sse-endpoint: /custom-sse
        type: async # default async
  devtools:
    restart:
      enabled: true
    livereload:
      enabled: true

logging:
  level:
    root: INFO
            </pre>
        </li>
    </ol>
    <h5>2) MCP Server webflux</h5>
    <ol>
        <li>build.gradle
            <pre style="border:1px solid cornflowerblue">

                dependencies {
                    compileOnly 'org.projectlombok:lombok'
                    developmentOnly 'org.springframework.boot:spring-boot-devtools'
                    annotationProcessor 'org.projectlombok:lombok'
                    testImplementation 'org.springframework.boot:spring-boot-starter-test'
                    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

                    implementation 'org.springframework.ai:spring-ai-starter-mcp-server-webflux'
                }
            </pre>
        </li>
        <li>application.yml
            <pre style="border:1px solid cornflowerblue">

server:
  port: 8089

spring:
  application:
    name: project
  profiles:
    active: local
  ai:
    mcp:
      server:
        name: mcp-server-time-webflux
        version: 0.0.1
        request-timeout: 20s
        type: async # default sync
  devtools:
    restart:
      enabled: true
    livereload:
      enabled: true

logging:
  level:
    root: INFO
            </pre>
        </li>
    </ol>
    <h5>3) MCP Server stdio</h5>
    <ol>
        <li>build.gradle
            <pre style="border:1px solid cornflowerblue">

                dependencies {
                    implementation 'org.springframework.ai:spring-ai-starter-mcp-server'
                    implementation 'org.springframework:spring-web'
                    compileOnly 'org.projectlombok:lombok'
                    annotationProcessor 'org.projectlombok:lombok'
                    testImplementation 'org.springframework.boot:spring-boot-starter-test'
                    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
                }
            </pre>
        </li>
        <li>application.yml
            <pre style="border:1px solid cornflowerblue">

server:
  servlet:
    encoding:
      charset: UTF-8
spring:
  application:
    name: mcp-server-weather-forecast-stdio
  main:
    web-application-type: none
    banner-mode: off
  ai:
    mcp:
      server:
        name: mcp-server-weather-forecast-stdio
        version: "0.0.1"
logging:
  charset:
    file: UTF-8
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logger{39} : %msg%n"
  file:
    name: mcp-server-weather-forecast-stdio.log
            </pre>
        </li>
        <li>mcp-servers.json: jar 파일 생성은 Gradle > build > bootJar
            <pre style="border:1px solid cornflowerblue">

{
  "mcpServers": {
    "mcp-server-weather-forecast-stdio": {
      "command": "java",
      "args": [
        "-Dspring.ai.mcp.server.stdio=true",
        "-Dspring.main.web-application-type=none",
        "-Dlogging.pattern.console=",
        "-jar",
        "C:/edu/springai_chapter9/mcp-server-weather-forecast-stdio/build/libs/mcp-server-weather-forecast-stdio-0.0.1-SNAPSHOT.jar"
      ]
    }
  }
}
            </pre>
        </li>
    </ol>


</th:block>

</html>