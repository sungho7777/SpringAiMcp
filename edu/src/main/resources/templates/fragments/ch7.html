<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">

<th:block>

    <h1>Chapter 7. Embedding Model</h1><br>

    <h2>1. Embedding Model</h2>
    <a href="https://docs.spring.io/spring-ai/reference/api/vectordbs/understand-vectordbs.html">벡터 이해, 출처:docs.springai.io</a><br>
    <img th:src="@{/imgs/embedding.png}" width="600px;"><br><a href="https://qdrant.tech/articles/what-are-embeddings/">출처:qdrant.tech</a><br><br>

    <p>
        임베딩(Embedding)은 텍스트, 이미지, 비디오 같은 데이터를 의미 기반 벡터 형태(부동 소수점 숫자 배열)로 변환하여
        입력 간 관계와 의미적 유사성을 수치적으로 표현하는 기술입니다.
        이 벡터 배열의 길이를 <strong>벡터 차원(Vector Dimension)</strong>이라고 합니다.
    </p>

    <p>
        두 텍스트 또는 이미지의 벡터 간 <strong>수치적 거리(거리 기반 유사도)</strong>를 계산하여
        의미적 유사성을 비교할 수 있으며, 이를 기반으로 검색, 분류, 클러스터링 등의 작업이 수행됩니다.
    </p>

    <p>
        Spring AI는 이러한 임베딩 작업을 단순화하기 위해 <code>EmbeddingModel</code> 인터페이스를 제공하며,
        텍스트를 임베딩 벡터로 자연스럽게 변환하여 다양한 AI·ML 기반 기능과 연동할 수 있게 합니다.
    </p>

    <h3>EmbeddingModel 인터페이스의 설계 목표</h3>

    <ul>
        <li>
            <strong>Portability</strong>
            다양한 임베딩 모델 간 전환이 용이하도록 설계되어, 최소한의 코드 변경만으로 모델 교체가 가능합니다.
        </li>
        <li>
            <strong>Simplicity</strong>
            <code>embed(String text)</code>, <code>embed(Document document)</code> 같은 단순화된 API를 통해
            복잡한 알고리즘 처리 없이 임베딩 기능을 쉽게 활용할 수 있습니다.
        </li>
    </ul>

    <p>
        Spring AI는 임베딩을 활용한 <strong>RAG(Retrieval Augmented Generation)</strong> 아키텍처를 직접 구성하거나,
        Spring에서 제공하는 기본 RAG 플로우를 사용할 수 있도록 모듈식 구조를 제공합니다.
    </p>

    <hr>

    <h2>2. Vector Databases</h2>

    <p>
        벡터 데이터베이스는 벡터 임베딩을 저장하고 유사도 기반 검색을 수행하는 특수 데이터베이스로,
        AI 애플리케이션에서 필수적인 역할을 합니다.
    </p>

    <p>
        전통적인 관계형 데이터베이스의 “정확히 일치하는 값 검색”과 달리,
        벡터 데이터베이스는 특정 벡터와 <strong>의미적으로 가장 유사한 벡터</strong>를 조회하는
        <strong>유사도 검색(Similarity Search)</strong>을 수행합니다.
    </p>

    <p>
        사용자의 질문이 들어오면:
    </p>

    <ol>
        <li>질문을 임베딩으로 변환</li>
        <li>벡터 DB에서 유사 문서 검색</li>
        <li>찾아온 문서를 AI 모델에 전달하여 응답 생성</li>
    </ol>

    <p>
        이 과정을 <strong>RAG(Retrieval Augmented Generation)</strong>이라고 합니다.
    </p>

    <h3>Document 객체</h3>
    <p>
        벡터 DB에 데이터를 저장하기 위해 Spring AI는 <code>Document</code> 객체를 사용합니다.
    </p>

    <ul>
        <li>텍스트(예: PDF, Word 등에서 추출)</li>
        <li>메타데이터(Key-Value 구조, 예: 파일명, 날짜, 태그)</li>
    </ul>

    <h3>임베딩 생성</h3>
    <p>
        벡터 DB는 임베딩을 “저장하고 검색”하는 역할만 하며,
        임베딩 자체는 <code>EmbeddingModel</code>이 생성합니다.
    </p>

    <p>예시:</p>
    <ul>
        <li>Word2Vec</li>
        <li>GLoVE</li>
        <li>BERT</li>
        <li>OpenAI Embedding Models(text-embedding-ada-002 등)</li>
    </ul>

    <h3>모델 선택 기준</h3>
    <p>
        사용 중인 LLM과 동일하거나 호환되는 임베딩 모델을 사용하는 것이 바람직합니다.
        예:
        <strong>OpenAI ChatGPT → OpenAiEmbeddingModel + text-embedding-ada-002</strong>
    </p>

    <hr>

    <h2>3. Similarity Search API</h2>

    <p>
        Spring AI의 벡터 저장소(VectorStore)에서는
        <code>similaritySearch</code> 메서드를 통해 유사 문서를 검색할 수 있습니다.
    </p>

    <h3>파라미터 설명</h3>

    <ul>
        <li><strong>k (topK)</strong>
            반환할 문서 개수(최근접 K개)
        </li>
        <li><strong>similarityThreshold</strong>
            0~1 범위의 유사도 기준값 (1에 가까울수록 엄격)
        </li>
        <li><strong>Filter.Expression</strong>
            메타데이터 기반의 필터링 (SQL WHERE 절과 유사)
        </li>
    </ul>

    <h3>예시 – DSL 기반 필터링</h3>

    <pre><code>return vectorStore.similaritySearch(
    SearchRequest.builder()
        .query(question)
        .topK(1)
        .similarityThreshold(0.5)
        .filterExpression(
            b.and(
                b.eq("director", director),
                b.gte("year", year)
            ).build()
        )
        .build()
);
</code></pre>

    <h3>예시 – ANTLR4 기반 문자열 DSL</h3>

    <pre><code>return vectorStore.similaritySearch(
    SearchRequest.builder()
        .query(question)
        .topK(1)
        .similarityThreshold(0.5)
        .filterExpression(
            "section == '%s' and name == '%s'".formatted(section, name)
        )
        .build()
);
</code></pre>

    <hr>






    <h2>4. PGvector</h2><br>
    <a href="https://docs.spring.io/spring-ai/reference/api/vectordbs/pgvector.html">출처:docs.springai.io</a><br>
    <p>PGvector 는 PostgreSQL용 오픈소스 확장 프로그램으로, 머신 러닝으로 생성된 임베딩을 저장하고 검색할 수 있도록 지원합니다. 사용자가 정확한 이웃과 대략적인 최근접 이웃을 모두 식별할 수 있도록 다양한 기능을 제공합니다. 인덱싱 및 쿼리를 포함한 다른 PostgreSQL 기능과 원활하게 작동하도록 설계되었습니다.</p>
    <p>Spring AI에사 PGvector를 사용하면 Springboot가 시작 되면서 기본적으로 PostgreSQL에 vector_store라는 테이블이 생성 되면서 동작 합니다. </p>
    <p>필요 하면 사용자가 테이블을 생성 하여 사용이 가능 합니다.</p>
    <p>만약 chat memory를 PGvector에 저장 한다면 이때도 자동적으로 spring_ai_chat_memory라는 테이블이 생성이 됩니다.</p>
    <p>다음은 PGVector를 사용하기위한 Spring Boot에서의 환경 설정 입니다.(yml)</p>
    <pre style="border:1px solid cornflowerblue">

        spring:
          datasource:
            url: jdbc:postgresql://localhost:5432/postgres
            username: user01
            password: 111111
            driver-class-name: org.postgresql.Driver
          ai:
            chat:
              memory:
                repository:
                  jdbc:
                    # resources/schema/chat_pgvector.sql
                    schema: classpath:schema/chat_pgvector.sql
                    initialize-schema: always
            vectorstore:
              pgvector:
                initialize-schema: true
    </pre><br>
    <p>resources/schema/chat_pgvector.sql</p>
    <pre style="border:1px solid cornflowerblue">

        DROP TABLE IF EXISTS chat_pgvector CASCADE;
        CREATE TABLE IF NOT EXISTS public.chat_pgvector (
            id VARCHAR(255) PRIMARY KEY,
            content TEXT,
            metadata JSONB,
            embedding VECTOR(1536)
        );
    </pre>


</th:block>

</html>